<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Ketsu - Porteador GD Pro</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        :root {
            --apple-blue: #0A84FF;
            --apple-music-pink: #FA233B;
            --text-main: #FFFFFF;
            --text-muted: rgba(255, 255, 255, 0.7);
        }
        body { 
            font-family: -apple-system, BlinkMacSystemFont, "SF Pro Display", sans-serif; 
            text-align: center; 
            padding: 20px; 
            margin: 0;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #121212;
            color: var(--text-main); 
        }
        .glass-card {
            background: #1c1c1e;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 32px;
            padding: 40px 25px;
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
            width: 100%;
            max-width: 450px;
            box-sizing: border-box;
        }
        .profile-container {
            margin-bottom: 25px;
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
        }
        .marco-ketsu {
            position: absolute;
            width: 140px; 
            height: 140px;
            top: -25px; 
            pointer-events: none;
            z-index: 10;
        }
        .profile-pic {
            width: 90px;
            height: 90px;
            border-radius: 50%;
            background: linear-gradient(45deg, var(--apple-blue), var(--apple-music-pink));
            padding: 3px; 
            box-shadow: 0 8px 20px rgba(0,0,0,0.4);
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }
        .profile-pic img {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            object-fit: cover;
            background: #1c1c1e;
            display: block; 
        }
        h1.welcome-text {
            margin: 0;
            font-weight: 800;
            font-size: 24px;
            background: linear-gradient(to right, #fff, #a1a1a6);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .subtitle { color: var(--text-muted); font-size: 14px; margin-bottom: 25px; font-weight: 500;}
        #dropzone {
            background: #2c2c2e;
            padding: 40px 20px;
            border-radius: 24px;
            margin: 20px 0;
            cursor: pointer;
            border: 2px dashed #4a4a4c;
        }
        #dropzone:active { transform: scale(0.96); background: #3a3a3c; }
        .drop-icon { font-size: 45px; margin-bottom: 15px; display: block; }
        .drop-text-main { font-weight: 600; font-size: 18px; margin: 0; }
        .drop-text-sub { color: var(--text-muted); font-size: 14px; margin-top: 8px; }
        .btn { 
            background: var(--apple-blue); 
            color: #ffffff; 
            padding: 18px 30px; 
            border-radius: 22px; 
            font-weight: 700; 
            border: none;
            font-size: 17px;
            margin-top: 25px;
            width: 100%;
            display: inline-block;
            text-decoration: none;
            box-sizing: border-box;
        }
        .btn:active { transform: scale(0.96); opacity: 0.9; }
        #status-container { margin-top: 25px; min-height: 40px; }
        #status-text { font-size: 16px; font-weight: 600; margin-bottom: 5px; }
        #progress-detail { font-size: 13px; color: var(--text-muted); word-break: break-all; }
        #fileInput { display: none; }
        #downloadArea { margin-top: 10px; }
        #error-log { color: #ff453a; font-size: 12px; margin-top: 10px; text-align: left; }
    </style>
</head>
<body>
    <div class="glass-card">
        <div class="profile-container">
            <img class="marco-ketsu" src="marco.gif" alt="Marco" onerror="this.style.display='none'">
            <div class="profile-pic" id="profilePic">
                <img id="ketsuImg" src="foto.jpg" alt="Ketsu" style="display: block;">
            </div>
            <h1 class="welcome-text">Ketsu te da la bienvenida</h1>
        </div>

        <p class="subtitle">Motor V20: El Recorte Exacto (Fix Tijeras)</p>
        
        <div id="dropzone">
            <span class="drop-icon">‚úÇÔ∏è</span>
            <h3 class="drop-text-main">Toca para subir archivos</h3>
            <p class="drop-text-sub">El m√©todo puro que pediste, sin fallos.</p>
        </div>
        
        <input type="file" id="fileInput" multiple>
        
        <div id="status-container">
            <div id="status-text">‚ú® Listo para portear</div>
            <div id="progress-detail">Soporte masivo activado...</div>
        </div>
        
        <div id="error-log"></div>
        <div id="downloadArea"></div>
    </div>

    <script>
        const dropzone = document.getElementById('dropzone');
        const fileInput = document.getElementById('fileInput');
        const statusText = document.getElementById('status-text');
        const progressDetail = document.getElementById('progress-detail');
        const downloadArea = document.getElementById('downloadArea');
        const errorLog = document.getElementById('error-log');

        dropzone.addEventListener('click', () => fileInput.click());
        fileInput.addEventListener('change', (e) => {
            if(e.target.files.length > 0) procesarArchivos(e.target.files);
        });

        const pausaUI = () => new Promise(resolve => setTimeout(resolve, 5));

        function getDictNode(dictNode, keyName) {
            for(let i = 0; i < dictNode.children.length; i += 2) {
                if(dictNode.children[i].textContent === keyName) return dictNode.children[i+1];
            }
            return null;
        }

        function setDictNodeText(dictNode, keyName, newValue) {
            for(let i = 0; i < dictNode.children.length; i += 2) {
                if(dictNode.children[i].textContent === keyName) {
                    dictNode.children[i+1].textContent = newValue;
                    return;
                }
            }
        }

        function dividirStringMitad(str) {
            return str.replace(/-?[\d.]+/g, match => {
                let num = parseFloat(match) / 2;
                return Number.isInteger(num) ? num : parseFloat(num.toFixed(2));
            });
        }

        function procesarIconoGDColon(imagenBlob, plistTexto) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = async () => {
                    try {
                        const parser = new DOMParser();
                        const xmlDoc = parser.parseFromString(plistTexto, "text/xml");
                        const topDict = xmlDoc.querySelector("plist > dict");
                        let framesDict = getDictNode(topDict, "frames");
                        let metadataDict = getDictNode(topDict, "metadata");

                        let format = 3; 
                        if(metadataDict) {
                            let fVal = getDictNode(metadataDict, "format");
                            if(fVal) format = parseInt(fVal.textContent);
                        }

                        let piezasExtraidas = [];

                        // 1. DESPLISTEAR: LEER Y EXTRAER CON LAS MEDIDAS REALES
                        for(let i = 0; i < framesDict.children.length; i += 2) {
                            let nameKey = framesDict.children[i];
                            let frameData = framesDict.children[i+1];
                            if(nameKey.tagName !== "key" || frameData.tagName !== "dict") continue;

                            let pieza = { name: nameKey.textContent, dictNode: frameData };

                            let rectNode = getDictNode(frameData, "textureRect") || getDictNode(frameData, "frame");
                            let rotatedNode = getDictNode(frameData, "textureRotated") || getDictNode(frameData, "rotated");
                            pieza.isRotated = rotatedNode ? (rotatedNode.tagName === "true") : false;

                            if (rectNode) {
                                let coords = rectNode.textContent.match(/-?[\d.]+/g).map(Number);
                                pieza.xOrig = coords[0]; 
                                pieza.yOrig = coords[1];
                                pieza.rectNode = rectNode;

                                // EL FIX PRINCIPAL: Leer bien qu√© es F√≠sico y qu√© es L√≥gico seg√∫n el Formato
                                if (format === 3) {
                                    pieza.logicalW = coords[2];
                                    pieza.logicalH = coords[3];
                                    pieza.physW = pieza.isRotated ? coords[3] : coords[2];
                                    pieza.physH = pieza.isRotated ? coords[2] : coords[3];
                                } else {
                                    pieza.physW = coords[2];
                                    pieza.physH = coords[3];
                                    pieza.logicalW = pieza.isRotated ? coords[3] : coords[2];
                                    pieza.logicalH = pieza.isRotated ? coords[2] : coords[3];
                                }

                                // Encoger todo a la mitad exacta
                                pieza.newPhysW = pieza.physW / 2;
                                pieza.newPhysH = pieza.physH / 2;
                                pieza.newLogicalW = pieza.logicalW / 2;
                                pieza.newLogicalH = pieza.logicalH / 2;

                                if (pieza.physW > 0 && pieza.physH > 0) {
                                    // Aislar la pieza EXACTA en un canvas miniatura
                                    const physCanvas = document.createElement('canvas');
                                    physCanvas.width = Math.ceil(pieza.physW);
                                    physCanvas.height = Math.ceil(pieza.physH);
                                    physCanvas.getContext('2d').drawImage(img, pieza.xOrig, pieza.yOrig, pieza.physW, pieza.physH, 0, 0, pieza.physW, pieza.physH);

                                    // Crear el canvas encogido
                                    const canvasMitad = document.createElement('canvas');
                                    canvasMitad.width = Math.max(1, Math.ceil(pieza.newPhysW));
                                    canvasMitad.height = Math.max(1, Math.ceil(pieza.newPhysH));
                                    const ctxMitad = canvasMitad.getContext('2d');
                                    ctxMitad.imageSmoothingEnabled = true;
                                    ctxMitad.imageSmoothingQuality = 'high';
                                    ctxMitad.drawImage(physCanvas, 0, 0, pieza.physW, pieza.physH, 0, 0, pieza.newPhysW, pieza.newPhysH);

                                    pieza.imagenLista = canvasMitad;
                                }
                                piezasExtraidas.push(pieza);
                            }
                        }
                        await pausaUI();

                        // 2. RE-EMPAQUETAR
                        piezasExtraidas.sort((a, b) => b.newPhysH - a.newPhysH);
                        let padding = 2; 
                        let posX = padding, posY = padding, alturaFila = 0, maxAncho = 0;

                        piezasExtraidas.forEach(p => {
                            if (p.newPhysW > 0) {
                                if (posX + p.newPhysW + padding > 1024) { 
                                    posX = padding;
                                    posY += alturaFila + padding;
                                    alturaFila = 0;
                                }
                                p.nuevoX = posX;
                                p.nuevoY = posY;
                                
                                posX += p.newPhysW + padding;
                                if (p.newPhysH > alturaFila) alturaFila = p.newPhysH;
                                if (posX > maxAncho) maxAncho = posX;
                            }
                        });

                        let anchoHojaFinal = Math.pow(2, Math.ceil(Math.log2(Math.max(2, maxAncho))));
                        let altoHojaFinal = Math.pow(2, Math.ceil(Math.log2(Math.max(2, posY + alturaFila + padding))));
                        
                        const canvasFinal = document.createElement('canvas');
                        canvasFinal.width = anchoHojaFinal;
                        canvasFinal.height = altoHojaFinal;
                        const ctxFinal = canvasFinal.getContext('2d');

                        // 3. REPLISTEAR: DIVIDIR TODOS LOS TAMA√ëOS Y OFFSETS A LA MITAD
                        piezasExtraidas.forEach(p => {
                            if(p.imagenLista) {
                                ctxFinal.drawImage(p.imagenLista, p.nuevoX, p.nuevoY);

                                let nx = Number.isInteger(p.nuevoX) ? p.nuevoX : parseFloat(p.nuevoX.toFixed(2));
                                let ny = Number.isInteger(p.nuevoY) ? p.nuevoY : parseFloat(p.nuevoY.toFixed(2));
                                
                                let nw, nh;
                                if (format === 3) {
                                    nw = Number.isInteger(p.newLogicalW) ? p.newLogicalW : parseFloat(p.newLogicalW.toFixed(2));
                                    nh = Number.isInteger(p.newLogicalH) ? p.newLogicalH : parseFloat(p.newLogicalH.toFixed(2));
                                } else {
                                    nw = Number.isInteger(p.newPhysW) ? p.newPhysW : parseFloat(p.newPhysW.toFixed(2));
                                    nh = Number.isInteger(p.newPhysH) ? p.newPhysH : parseFloat(p.newPhysH.toFixed(2));
                                }
                                
                                p.rectNode.textContent = `{{${nx},${ny}},{${nw},${nh}}}`;
                            }

                            // Divide absolutamente todos los otros atributos a la mitad (No tocamos la rotaci√≥n)
                            let keysAEncoger = ["spriteOffset", "offset", "spriteSize", "spriteSourceSize", "sourceSize", "sourceColorRect"];
                            keysAEncoger.forEach(llave => {
                                let nodo = getDictNode(p.dictNode, llave);
                                if (nodo) {
                                    nodo.textContent = dividirStringMitad(nodo.textContent);
                                }
                            });
                        });

                        // 4. ACTUALIZAR METADATOS Y TAMA√ëO TOTAL
                        if(metadataDict) {
                            setDictNodeText(metadataDict, "size", `{${anchoHojaFinal},${altoHojaFinal}}`);
                            
                            let fName1Node = getDictNode(metadataDict, "realTextureFileName");
                            if (fName1Node) fName1Node.textContent = fName1Node.textContent.replace(/-uhd\.png/gi, '-hd.png').replace(/-uhd\.pvr/gi, '-hd.pvr').replace(/-hd\.png/gi, '.png').replace(/-hd\.pvr/gi, '.pvr');
                            
                            let fName2Node = getDictNode(metadataDict, "textureFileName");
                            if (fName2Node) fName2Node.textContent = fName2Node.textContent.replace(/-uhd\.png/gi, '-hd.png').replace(/-uhd\.pvr/gi, '-hd.pvr').replace(/-hd\.png/gi, '.png').replace(/-hd\.pvr/gi, '.pvr');
                        }

                        let plistTextoFinal = new XMLSerializer().serializeToString(xmlDoc);
                        if (!plistTextoFinal.includes("DOCTYPE")) {
                            plistTextoFinal = '<?xml version="1.0" encoding="UTF-8"?>\n<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">\n' + plistTextoFinal.replace(/<\?xml.*\?>/, '');
                        }

                        canvasFinal.toBlob(blobGenerado => resolve({ blob: blobGenerado, plistTextoFinal: plistTextoFinal }), 'image/png');
                    } catch (err) {
                        reject(err);
                    }
                };
                img.onerror = () => reject("Imagen corrupta");
                img.src = URL.createObjectURL(imagenBlob);
            });
        }

        async function procesarArchivos(files) {
            downloadArea.innerHTML = "";
            errorLog.innerHTML = "";
            const finalZip = new JSZip();
            let archivosBase = [];
            let basuraEliminada = 0;

            for (let archivo of files) {
                if (archivo.name.toLowerCase().endsWith('.zip')) {
                    statusText.innerHTML = `üì¶ Analizando ZIP...`;
                    await pausaUI();
                    try {
                        const zipCargado = await JSZip.loadAsync(archivo);
                        for (let ruta in zipCargado.files) {
                            if (ruta.includes('__MACOSX') || ruta.split('/').pop().startsWith('._')) {
                                basuraEliminada++; 
                            } else if (!zipCargado.files[ruta].dir) {
                                archivosBase.push({ nombre: ruta, data: zipCargado.files[ruta], esZip: true });
                            }
                        }
                    } catch(e) { errorLog.innerHTML += `‚ùå Error leyendo ZIP<br>`; }
                } else {
                    if (archivo.name.includes('__MACOSX') || archivo.name.startsWith('._')) {
                        basuraEliminada++;
                    } else {
                        archivosBase.push({ nombre: archivo.name, data: archivo, esZip: false });
                    }
                }
            }

            let grupos = {};
            for (let item of archivosBase) {
                let base = item.nombre.replace(/-uhd/gi, '').replace(/-hd/gi, '').replace(/\.(png|plist)$/i, '');
                if (!grupos[base]) grupos[base] = {};
                
                if (item.nombre.toLowerCase().endsWith('.png')) grupos[base].png = item;
                if (item.nombre.toLowerCase().endsWith('.plist')) grupos[base].plist = item;
            }

            let procesados = 0;
            let total = Object.keys(grupos).filter(k => grupos[k].png && grupos[k].plist).length;
            let actual = 1;

            if (basuraEliminada > 0) {
                errorLog.innerHTML = `<span style="color:#32d74b;">‚úÖ Se ignoraron ${basuraEliminada} archivos de basura.</span><br>`;
            }

            for (let llave in grupos) {
                let grupo = grupos[llave];
                if (!grupo.png || !grupo.plist) continue;

                statusText.innerHTML = `‚öôÔ∏è Procesando ${actual} de ${total}...`;
                progressDetail.innerHTML = llave.split('/').pop();
                await pausaUI();

                try {
                    const textoPlistBruto = grupo.plist.esZip ? await grupo.plist.data.async("text") : await grupo.plist.data.text();
                    const imagenBlobBruto = grupo.png.esZip ? await grupo.png.data.async("blob") : grupo.png.data;
                    
                    const resultado = await procesarIconoGDColon(imagenBlobBruto, textoPlistBruto);
                    
                    let nombreFinal = grupo.png.nombre;
                    if(nombreFinal.toLowerCase().includes('-uhd')) {
                        nombreFinal = nombreFinal.replace(/-uhd/gi, '-hd');
                    } else if(nombreFinal.toLowerCase().includes('-hd')) {
                        nombreFinal = nombreFinal.replace(/-hd/gi, ''); 
                    }

                    finalZip.file(nombreFinal, resultado.blob);
                    finalZip.file(nombreFinal.replace('.png', '.plist'), resultado.plistTextoFinal);
                    procesados++;
                } catch (error) {
                    errorLog.innerHTML += `‚ùå Error en ${llave}<br>`;
                    console.error(error);
                }
                actual++;
            }

            if (procesados === 0) {
                statusText.innerHTML = "‚ö†Ô∏è Hubo un error procesando.";
                return;
            }

            statusText.innerHTML = "üì¶ Empaquetando ZIP Final...";
            progressDetail.innerHTML = "Casi listo...";
            await pausaUI();

            const zipBlob = await finalZip.generateAsync({type:"blob", compression: "DEFLATE", compressionOptions: { level: 6 }});
            const urlDescarga = URL.createObjectURL(zipBlob);
            
            downloadArea.innerHTML = `<a href="${urlDescarga}" download="Ketsu_V20_Fix_Final.zip" class="btn">‚Üì Descargar Texturas Finales</a>`;
            statusText.innerHTML = `üéâ ¬°${procesados} Iconos Listos!`;
            progressDetail.innerHTML = "Geometr√≠a alineada. Cero errores.";
        }
    </script>
</body>
</html>
