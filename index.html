<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Ketsu - Porteador GD Pro</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        :root {
            --apple-blue: #0A84FF;
            --apple-music-pink: #FA233B;
            --text-main: #FFFFFF;
            --text-muted: rgba(255, 255, 255, 0.7);
        }

        body { 
            font-family: -apple-system, BlinkMacSystemFont, "SF Pro Display", sans-serif; 
            text-align: center; 
            padding: 20px; 
            margin: 0;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #121212;
            color: var(--text-main); 
        }

        .glass-card {
            background: #1c1c1e;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 32px;
            padding: 40px 25px;
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
            width: 100%;
            max-width: 450px;
            box-sizing: border-box;
        }

        .profile-container {
            margin-bottom: 25px;
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
        }
        
        .marco-ketsu {
            position: absolute;
            width: 140px; 
            height: 140px;
            top: -25px; 
            pointer-events: none;
            z-index: 10;
        }

        .profile-pic {
            width: 90px;
            height: 90px;
            border-radius: 50%;
            background: linear-gradient(45deg, var(--apple-blue), var(--apple-music-pink));
            padding: 3px; 
            box-shadow: 0 8px 20px rgba(0,0,0,0.4);
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }
        
        .profile-pic img {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            object-fit: cover;
            background: #1c1c1e;
            display: block; 
        }

        h1.welcome-text {
            margin: 0;
            font-weight: 800;
            font-size: 24px;
            background: linear-gradient(to right, #fff, #a1a1a6);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .subtitle { color: var(--text-muted); font-size: 14px; margin-bottom: 25px; font-weight: 500;}
        
        #dropzone {
            background: #2c2c2e;
            padding: 40px 20px;
            border-radius: 24px;
            margin: 20px 0;
            cursor: pointer;
            border: 2px dashed #4a4a4c;
        }
        #dropzone:active { transform: scale(0.96); background: #3a3a3c; }
        
        .drop-icon { font-size: 45px; margin-bottom: 15px; display: block; }
        .drop-text-main { font-weight: 600; font-size: 18px; margin: 0; }
        .drop-text-sub { color: var(--text-muted); font-size: 14px; margin-top: 8px; }

        .btn { 
            background: var(--apple-blue); 
            color: #ffffff; 
            padding: 18px 30px; 
            border-radius: 22px; 
            font-weight: 700; 
            border: none;
            font-size: 17px;
            margin-top: 25px;
            width: 100%;
            display: inline-block;
            text-decoration: none;
            box-sizing: border-box;
        }
        .btn:active { transform: scale(0.96); opacity: 0.9; }

        #status-container { margin-top: 25px; min-height: 40px; }
        #status-text { font-size: 16px; font-weight: 600; margin-bottom: 5px; }
        #progress-detail { font-size: 13px; color: var(--text-muted); word-break: break-all; }
        
        #fileInput { display: none; }
        #downloadArea { margin-top: 10px; }
        #error-log { color: #ff453a; font-size: 12px; margin-top: 10px; text-align: left; }
    </style>
</head>
<body>

    <div class="glass-card">
        <div class="profile-container">
            <img class="marco-ketsu" src="marco.gif" alt="Marco" onerror="this.style.display='none'">
            <div class="profile-pic" id="profilePic">
                <img id="ketsuImg" src="foto.jpg" alt="Ketsu" style="display: block;">
            </div>
            <h1 class="welcome-text">Ketsu te da la bienvenida</h1>
        </div>

        <p class="subtitle">Motor V11: Split & Repack GD Colon</p>
        
        <div id="dropzone">
            <span class="drop-icon">üß©</span>
            <h3 class="drop-text-main">Toca para subir archivos</h3>
            <p class="drop-text-sub">Desplistea y re-empaqueta sin errores</p>
        </div>
        
        <input type="file" id="fileInput" multiple>
        
        <div id="status-container">
            <div id="status-text">‚ú® Listo para portear</div>
            <div id="progress-detail">Soporte masivo activado...</div>
        </div>
        
        <div id="error-log"></div>
        <div id="downloadArea"></div>
    </div>

    <script>
        const dropzone = document.getElementById('dropzone');
        const fileInput = document.getElementById('fileInput');
        const statusText = document.getElementById('status-text');
        const progressDetail = document.getElementById('progress-detail');
        const downloadArea = document.getElementById('downloadArea');
        const errorLog = document.getElementById('error-log');

        dropzone.addEventListener('click', () => fileInput.click());

        fileInput.addEventListener('change', (e) => {
            if(e.target.files.length > 0) procesarArchivos(e.target.files);
        });

        const pausaUI = () => new Promise(resolve => setTimeout(resolve, 15));

        // üî• MOTOR V11: SPLIT EXACTO TIPO GD COLON üî•
        function procesarIconoGDColon(imagenBlob, plistTexto) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = async () => {
                    try {
                        const parser = new DOMParser();
                        const xmlDoc = parser.parseFromString(plistTexto, "text/xml");
                        const topDict = xmlDoc.querySelector("plist > dict");
                        let framesDict = null;
                        let metadataDict = null;

                        for(let i = 0; i < topDict.children.length; i++) {
                            if(topDict.children[i].tagName === "key" && topDict.children[i].textContent === "frames") framesDict = topDict.children[i+1];
                            if(topDict.children[i].tagName === "key" && topDict.children[i].textContent === "metadata") metadataDict = topDict.children[i+1];
                        }

                        let piezasExtraidas = [];

                        // 1. DESPLISTEAR: Cortar cada imagen por separado
                        for(let i = 0; i < framesDict.children.length; i += 2) {
                            let nameKey = framesDict.children[i];
                            let frameData = framesDict.children[i+1];
                            if(nameKey.tagName !== "key" || frameData.tagName !== "dict") continue;

                            let pieza = { name: nameKey.textContent, isRotated: false };

                            for(let j = 0; j < frameData.children.length; j += 2) {
                                let pKey = frameData.children[j].textContent;
                                let pVal = frameData.children[j+1];

                                if(pKey === "textureRect" || pKey === "frame") {
                                    let coords = pVal.textContent.match(/-?[\d.]+/g).map(Number);
                                    pieza.xOrig = coords[0]; pieza.yOrig = coords[1];
                                    pieza.wLogico = coords[2]; pieza.hLogico = coords[3]; 
                                    pieza.rectNode = pVal;
                                } else if (pKey === "textureRotated" || pKey === "rotated") {
                                    pieza.isRotated = (pVal.tagName === "true");
                                } else if (pKey === "spriteOffset" || pKey === "offset") {
                                    pieza.offsetNode = pVal;
                                } else if (pKey === "spriteSize") {
                                    pieza.sizeNode = pVal;
                                } else if (pKey === "spriteSourceSize" || pKey === "sourceSize") {
                                    pieza.sourceSizeNode = pVal;
                                } else if (pKey === "sourceColorRect") {
                                    pieza.sourceColorRectNode = pVal;
                                }
                            }

                            pieza.wFisico = pieza.isRotated ? pieza.hLogico : pieza.wLogico;
                            pieza.hFisico = pieza.isRotated ? pieza.wLogico : pieza.hLogico;
                            piezasExtraidas.push(pieza);
                        }

                        // 2. REDIMENSIONAR DE UNA POR UNA (Como tus im√°genes sueltas)
                        for(let pieza of piezasExtraidas) {
                            if(pieza.wFisico > 0 && pieza.hFisico > 0) {
                                const canvasOriginal = document.createElement('canvas');
                                canvasOriginal.width = Math.ceil(pieza.wFisico);
                                canvasOriginal.height = Math.ceil(pieza.hFisico);
                                const ctxOrig = canvasOriginal.getContext('2d');
                                ctxOrig.drawImage(img, pieza.xOrig, pieza.yOrig, pieza.wFisico, pieza.hFisico, 0, 0, pieza.wFisico, pieza.hFisico);

                                // Usamos Math.ceil para no cortar pixeles difuminados en medidas impares
                                pieza.wFisicoMitad = Math.ceil(pieza.wFisico / 2);
                                pieza.hFisicoMitad = Math.ceil(pieza.hFisico / 2);
                                
                                const canvasMitad = document.createElement('canvas');
                                canvasMitad.width = pieza.wFisicoMitad;
                                canvasMitad.height = pieza.hFisicoMitad;
                                const ctxMitad = canvasMitad.getContext('2d');
                                ctxMitad.imageSmoothingEnabled = true;
                                ctxMitad.imageSmoothingQuality = 'high';
                                
                                ctxMitad.drawImage(canvasOriginal, 0, 0, pieza.wFisico, pieza.hFisico, 0, 0, pieza.wFisicoMitad, pieza.hFisicoMitad);
                                
                                pieza.imagenLista = canvasMitad; 
                            } else {
                                pieza.wFisicoMitad = 0;
                                pieza.hFisicoMitad = 0;
                            }
                            await pausaUI();
                        }

                        // 3. VOLVER A JUNTAR (El re-empaquetado)
                        piezasExtraidas.sort((a, b) => b.hFisicoMitad - a.hFisicoMitad);
                        let padding = 2; // Margen para evitar l√≠neas
                        let posX = padding, posY = padding, alturaFila = 0, maxAncho = 0;

                        piezasExtraidas.forEach(p => {
                            if (posX + p.wFisicoMitad + padding > 1024) { 
                                posX = padding;
                                posY += alturaFila + padding;
                                alturaFila = 0;
                            }
                            p.nuevoX = posX;
                            p.nuevoY = posY;
                            
                            posX += p.wFisicoMitad + padding;
                            if (p.hFisicoMitad > alturaFila) alturaFila = p.hFisicoMitad;
                            if (posX > maxAncho) maxAncho = posX;
                        });

                        let anchoHojaFinal = Math.pow(2, Math.ceil(Math.log2(Math.max(2, maxAncho))));
                        let altoHojaFinal = Math.pow(2, Math.ceil(Math.log2(Math.max(2, posY + alturaFila + padding))));
                        
                        const canvasFinal = document.createElement('canvas');
                        canvasFinal.width = anchoHojaFinal;
                        canvasFinal.height = altoHojaFinal;
                        const ctxFinal = canvasFinal.getContext('2d');

                        // Ajuste matem√°tico calcado de la f√≥rmula oficial
                        const reducirStr = (str) => str.replace(/(-?[\d.]+)/g, m => {
                            let n = parseFloat(m) / 2;
                            // Redondeamos para imitar la precisi√≥n de GD
                            n = Math.round(n * 100) / 100;
                            return Number.isInteger(n) ? n : n;
                        });

                        piezasExtraidas.forEach(p => {
                            if(p.imagenLista) ctxFinal.drawImage(p.imagenLista, p.nuevoX, p.nuevoY);

                            if(p.offsetNode) p.offsetNode.textContent = reducirStr(p.offsetNode.textContent);
                            if(p.sizeNode) p.sizeNode.textContent = reducirStr(p.sizeNode.textContent);
                            if(p.sourceSizeNode) p.sourceSizeNode.textContent = reducirStr(p.sourceSizeNode.textContent);
                            if(p.sourceColorRectNode) p.sourceColorRectNode.textContent = reducirStr(p.sourceColorRectNode.textContent);

                            let wLogicoNuevo = p.wLogico / 2;
                            let hLogicoNuevo = p.hLogico / 2;
                            wLogicoNuevo = Number.isInteger(wLogicoNuevo) ? wLogicoNuevo : parseFloat(wLogicoNuevo.toFixed(2));
                            hLogicoNuevo = Number.isInteger(hLogicoNuevo) ? hLogicoNuevo : parseFloat(hLogicoNuevo.toFixed(2));
                            let nx = Number.isInteger(p.nuevoX) ? p.nuevoX : parseFloat(p.nuevoX.toFixed(2));
                            let ny = Number.isInteger(p.nuevoY) ? p.nuevoY : parseFloat(p.nuevoY.toFixed(2));

                            if(p.rectNode) p.rectNode.textContent = `{{${nx},${ny}},{${wLogicoNuevo},${hLogicoNuevo}}}`;
                        });

                        // Renombrar el archivo por dentro para que el juego no lo estire
                        if(metadataDict) {
                            for(let i = 0; i < metadataDict.children.length; i += 2) {
                                let mKey = metadataDict.children[i].textContent;
                                let mVal = metadataDict.children[i+1];
                                if(mKey === "size") mVal.textContent = `{${anchoHojaFinal},${altoHojaFinal}}`;
                                else if (mKey === "realTextureFileName" || mKey === "textureFileName") {
                                    let fName = mVal.textContent;
                                    if(fName.toLowerCase().includes('-uhd')) {
                                        mVal.textContent = fName.replace(/-uhd\.png/gi, '-hd.png').replace(/-uhd\.pvr/gi, '-hd.pvr');
                                    } else if(fName.toLowerCase().includes('-hd')) {
                                        mVal.textContent = fName.replace(/-hd\.png/gi, '.png').replace(/-hd\.pvr/gi, '.pvr');
                                    }
                                }
                            }
                        }

                        let plistTextoFinal = new XMLSerializer().serializeToString(xmlDoc);
                        if (!plistTextoFinal.includes("DOCTYPE")) {
                            plistTextoFinal = '<?xml version="1.0" encoding="UTF-8"?>\n<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">\n' + plistTextoFinal.replace(/<\?xml.*\?>/, '');
                        }

                        canvasFinal.toBlob(blobGenerado => resolve({ blob: blobGenerado, plistTextoFinal: plistTextoFinal }), 'image/png');
                    } catch (err) {
                        reject(err);
                    }
                };
                img.onerror = () => reject("Imagen corrupta");
                img.src = URL.createObjectURL(imagenBlob);
            });
        }

        async function procesarArchivos(files) {
            downloadArea.innerHTML = "";
            errorLog.innerHTML = "";
            const finalZip = new JSZip();
            let archivosBase = [];

            for (let archivo of files) {
                if (archivo.name.toLowerCase().endsWith('.zip')) {
                    statusText.innerHTML = `üì¶ Extrayendo ${archivo.name}...`;
                    await pausaUI();
                    try {
                        const zipCargado = await JSZip.loadAsync(archivo);
                        for (let ruta in zipCargado.files) {
                            if (!zipCargado.files[ruta].dir) {
                                archivosBase.push({ nombre: ruta, data: zipCargado.files[ruta], esZip: true });
                            }
                        }
                    } catch(e) { errorLog.innerHTML += `‚ùå Error en ZIP: ${archivo.name}<br>`; }
                } else {
                    archivosBase.push({ nombre: archivo.name, data: archivo, esZip: false });
                }
            }

            let grupos = {};
            for (let item of archivosBase) {
                let base = item.nombre.replace(/-uhd/gi, '').replace(/-hd/gi, '').replace(/\.(png|plist)$/i, '');
                if (!grupos[base]) grupos[base] = {};
                
                if (item.nombre.toLowerCase().endsWith('.png')) grupos[base].png = item;
                if (item.nombre.toLowerCase().endsWith('.plist')) grupos[base].plist = item;
            }

            let procesados = 0;
            let total = Object.keys(grupos).filter(k => grupos[k].png && grupos[k].plist).length;
            let actual = 1;

            for (let llave in grupos) {
                let grupo = grupos[llave];
                if (!grupo.png || !grupo.plist) continue;

                statusText.innerHTML = `‚öôÔ∏è Procesando ${actual} de ${total}...`;
                progressDetail.innerHTML = "Cortando y encogiendo piezas una por una...";
                await pausaUI();

                try {
                    const textoPlistBruto = grupo.plist.esZip ? await grupo.plist.data.async("text") : await grupo.plist.data.text();
                    const imagenBlobBruto = grupo.png.esZip ? await grupo.png.data.async("blob") : grupo.png.data;
                    
                    const resultado = await procesarIconoGDColon(imagenBlobBruto, textoPlistBruto);
                    
                    // Renombrado inteligente (El Fix de las piezas voladoras)
                    let nombreFinal = grupo.png.nombre;
                    if(nombreFinal.toLowerCase().includes('-uhd')) {
                        nombreFinal = nombreFinal.replace(/-uhd/gi, '-hd');
                    } else if(nombreFinal.toLowerCase().includes('-hd')) {
                        nombreFinal = nombreFinal.replace(/-hd/gi, ''); 
                    }

                    finalZip.file(nombreFinal, resultado.blob);
                    finalZip.file(nombreFinal.replace('.png', '.plist'), resultado.plistTextoFinal);
                    procesados++;
                } catch (error) {
                    errorLog.innerHTML += `‚ùå Error en ${llave}<br>`;
                    console.error(error);
                }
                actual++;
            }

            if (procesados === 0) {
                statusText.innerHTML = "‚ö†Ô∏è Hubo un error procesando.";
                return;
            }

            statusText.innerHTML = "üì¶ Empaquetando ZIP Final...";
            progressDetail.innerHTML = "Casi listo...";
            await pausaUI();

            const zipBlob = await finalZip.generateAsync({type:"blob", compression: "DEFLATE", compressionOptions: { level: 6 }});
            const urlDescarga = URL.createObjectURL(zipBlob);
            
            downloadArea.innerHTML = `<a href="${urlDescarga}" download="Ketsu_GDColon_Pro.zip" class="btn">‚Üì Descargar Texturas Perfectas</a>`;
            statusText.innerHTML = `üéâ ¬°${procesados} Iconos Listos!`;
            progressDetail.innerHTML = "Geometr√≠a arreglada y Cero L√≠neas.";
        }
    </script>
</body>
</html>
